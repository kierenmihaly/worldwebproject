
20082020

 절차적 프로그래밍 언어 - 순서를 따르세여!

씨언어는 변수를 반드시 선언한다음에 실행해야함 ,

일련의 **처리 절차**를 정해진 문법에 따라 순서대로 기술해감 

데이터를 중심으로 프로시저를 구현 

- 절차적 프로그래밍 언어 장단점

    실행속도 빠름, 모듈 구성 용이, 구조적 프로그래밍(go to는 나올 수 없음) 가능 

    단점은 프로그램분석 어렵고, 유지보수 어렵고 코드수정 어려움 

- 절차적 프로그래밍 언어 종류

    c, algol, cobol, fortran 

    씨언어는 이식성이 좋다 - 다른 프로그램언어에 섞여서 사용할 수 있음 

객체지향 프로그래밍 언어

소프트웨어를 개발할 때 객체들을 조립해서 프로그램 작성

- 객체지향 프로그래밍 언어 장단점

    **재사용, 확장용이, 사용자-개발자 이해쉬움, 유지보수 용이** 

    단점 ; 처리시간 느림 

- 객체지향 프로그래밍 언어 종류

    자바, 씨쁠쁠, 스몰토크 

- 객체지향 프로그래밍 언어 구성요소

    **객체→ 데이터(속성), 연산(메소드) 을 결합한거 , 클래스(유사한 객체 묶), 메시지 (메소드 일으키는것, 상호작용)**

- 객체지향 프로그래밍 언어 특징

    **캡슐화 - 데이터 + 함수 묶는것 =⇒ 정보은닉**

    **추상화 - 불필요 생략, 중요한것만 중점** 

    **상속성 - 부모 속성 연산 물려받는것** 

    **다형성 - 고유한 방법으로 응답 예를들어 open이면 필통을 열고 현관문을 열고 노트북을 여는** 

스크립트 언어 

html문서안에 직접 프로그래밍 언어 삽입해서 사용 

예를들어 게시판 상품등록 용도로 사용 

서버용 asp, jsp, php, python ,, 

클라이언트용 java script - 클라이언트 웹브라우저에서 실행됨 

- 스크립트 언어 장단점

    컴파일 없이 바로 실행되기 때문에 배우고 코딩하기 쉽다, 개발시간 짧다, 쉽고 빠르게 수정 가능 

- 스크립트 언어 종류

    자바 스크립트, asp, jsp, php, python(인터프리터언어)

선언형 언어 

명령형 언어와 반대되는 개념의 언어로, 프로그램이 수행해야할 **문제를 기술 !** 

**함수형 언어(적용형 언어, 재귀호출 이용, 병렬처리 유리) ; 수학적 함수를 조합하여 문제를 해결하는 언어 , LISP**

**논리형 언어(선언적 언어, 비절차적) ; 기호 논리학에 기반을 둔 언어 - PROLOG 반복문, 선택문 사용하지 않는다** 

- 선언형 언어 장단점

    가독성이나 재사용성 

- 선언형 프로그래밍 언어 종류

    html, lisp(인공지능분야), prolog(논리학), xml(html단점 보안), haskell(함수형프로그램)

라이브러리 

프로그램을 효율적으로 개발할 수 있또록 자주 사용하는 함수나 데이터들을 모아놓은 집합체 

- 씨언어의 대표적인 표준 라이브러리
    - 헤더파일
        - Studio.h
        - Math.h
        - String,h
        - Stdlib.h
        - TIme.h

- 자바의 대표적인 표준 라이브러리

    import

    java.lang, java,util, java.io(입출력), java.net(네트워크), java.awt (사용자인터페이스)  등  예외처리

데이터 입출력 

- 씨언어 표준 입출력 - 키보드로 입력받아 화면으로 출력 !

    종류 ; scanf()- 먼가 입력받는거, getchar()- 한개 문자 입력받는거, gets()- 문자 입력해주세여, printf()- 출력할떄 , putchar()- 1개문자 표시해주세여 , puts()- 문자열 표시

- scanf() 함수

    형식 ; scanf(서식 문자열, 변수의 주소)

19082020

4-4

운영체제의 개념 - 자원들을 효율적으로 관리, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임 

- 운영체제의 목적
    - 처리 능력 ; 일정 시간 내에 시스템이 처리하는 일의 양
    - 반환 시간 ; 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
    - 사용 가능도 ; 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
    - 신뢰도 ; 시스템이 주어진 문제를 정확하게 해결하는 정도

windows

- pnp - 프린트나 사운드 카드 등의 하드웨어를 설치했을 떄, 필요한 시스템 환경을 운영체제가 자동으로 구성해줌
- oled ; object linking and embedding (개체의 연결과 삽입)

unix/linux/macos 

> 유닉스 특징, 커넬과 셀의 기능 구분!

다중사용자, 다중작업,  통신망 관리용 운영체제, 트리 구조

- **커널**

    컴터 부팅될 때 주 기억장치에 적재된 후 상주하면서 실행

    하드웨어 보호, 프로그램과 하드웨어 간의 인터페이스 역할 담당

    프로세스(cpu스케줄링) 관리, 기억장치 관리, 파일 관리, 입 출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능 수행 

- **쉘**

    사용자의 명령어 인식하여 프로그램 호출하고 명령을 수행하는 명령어 해석기 

    시스템과 사용자 간의 인터페이스 담당 

    dos의 command.com과 같은 기능 수행 

    주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재, 보조 기억장치에서 교체 처리가 가능 

    파이프라인(둘 이상의 명령을 함께 묶어 처리한 결과를 다른 명령의 입력으로 전환) 기능을 지원하고 입출력 재지정을 통해 출력과 입력의 방향을 변경 

- 리눅스의 개요 및 특징

    유닉스 기반으로 개발한 운영체제 

    프로그램 소스 코드가 무료로 공개되어 있어서, 프로그래머가 원하는 기능 추가가능, 다양한 플랫폼에 설치, 재배포 가능 

    유닉스와 완벽하게 호환

    대부분 특징이 유닉스와 동일 

기억장치 관리의 개요 

> 기억장치 계층 구조의 **특징**

- 특징

    기억장치는 레지스터, 캐시 기억장치, 주기억장치, 보조기억장치를 다음과 같이 계층 구조로 분류할 수 있다

    계층 구조에서 상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억용량이 적고 고가이다. (여기선 레지스터가 제일 가격이 높고 보조기억장치가 기억용량은 많고 가격도 낮다)

    주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며, 주소를 이용하여 엑세스할 수 있다. 

    레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 cpu가 직접 액세스 할 수 있으나 보조기억장치에 프로그램이나 데이터는 직접 엑세스할 수 없음 

    보조기억장치에 있는 데이터는 주기억장치에 적재된 후 cpu에 의해 엑세스될 수 있음

> 기억장치 관리 **전략에는 반입, 배치, 교체** 가있고 각각의 **의미, 종류**

- 기억장치 관리 전략 - 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것으로 반입,배치,교체 전략이 있음

- 반입 (fetch)

    보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지 결정하는 전략

    - 요구 반입(demand fatch) ; 요구할 때 적재하는 방법
    - 예상 반입 ; 미리 예샹하여 적재하는 방법
- 배치(placement)

    반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬것인지 

    - 최초(first fit) ; 첫 번째 분할 영역에 배치시키는 방법
    - 최적 ; 단편화(주기억장치의 분할된 영역에 프로그램이나 데이터 할당할 경우, 프로그램이나, 데이터보다 작거나 커서 생기는 **빈 기억 공간**) 를 가장 작게 남기는 분할 영역에 배치
    - 최악 ; 단편화를 가장 많이 남기는 분할 영역 배치
- 교체(replacement)

    어느 영역을 교체하여 사용할 것인지

가상기억장치 구현 기법/페이지 교체 알고리즘 

> 가상기억장치 특징,페이징과 세그먼테이션의 차이는 세그먼트는 크기가 불일정

- 가상기억장치 - 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로 , 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

    프로그램을 작은 블록(보조기억장치와 주기억장치 간에 전송되는 데이터의 최소단위) 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리

    주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용

    주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다

    가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환(가상기억장치에 있는 프로그램이 주기억장치에 적재되어 실행될 때 논리적인 가상주소를 물리적인 실기억주소로 변환하는 것, 매핑 이라고도 한다)작업이 필요 

- 페이징(paging) - 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
    - 페이지(프로그램을 일정한 크기로 나눈 단위), 페이지프레임(페이지 크기로 일정하게 나누어진 주기억장치의 단위)
    - 내부 단편화 발생할 수 있다
    - 주소 변환 위해서 페이지 위치 정보를 가지고 있는 페이지 맵 테이블 필요
    - 페이지 맵 테이블 사용으로 비용증가, 처리속도 감소

- 세그먼테이션(segmentation)

    가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법 

페이지 교체 알고리즘 - 페이지부재(page fault = 해당 페이지를 디스크에서 주기억장치로 가져와야함)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법

> 특징과 교체 원리,페이지 부재수 구하는법

OTP(optimal replacement) - 가장 오랫동안 사용하지 않을 페이지 교체

FIFO(first in first out) - 가장 먼저 들어와서 가장 오래 있었던 페이지 교체 

LRU(least resently used) - 최근에 가장 오랫동안 사용하지 않은 페이지 교체

LFU(least frequently used) - 사용 빈도가 가장 적은 페이지 교체

NUR(not used recently) - 최근에 사용하지 않은 페이지 교체 

SCR(second chance replacement) - 자주 사용되는 페이지의 교체 방지

가상기억장치 기타 관리 사항 

> 페이지 크기가 작으면 수가 늘어나고 크면 페이지의 수 줄어듦

- 페이지 크기 - 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에 따라 시스템에 미치는 영향이 다르다(페이지가 작을경우 와 클경우)
    - 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다
- locality - 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다