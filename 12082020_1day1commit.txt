테스트 자동화 도구 

- 테스트 자동화 개념 - 쉽고 효율적으로 테스트 수행, 사람의 실수줄일 수 있음 , 정확성유지, 품질 향상가능
- 테스트 자동화 도구의 장점,단점
    - 장점 - 데이터 재입력, 재구성 등의 반복작업을 자동화 → 시간단축 , 객관적인 평가 , 그래프 제공
    - 단점 - 사용법 교육 학습등이 필요, 비용발생
- 테스트 자동화 수행시 고려사항 - 모든 테스트과정 자동화 도구없음, 용도에 맞는 적절한 도구 선택, 환경설정, 습득 기간을 고려해서 프로젝트 일정을 계획해야함, 테스트 엔지니어도 프로젝트를 알아야하기 떄문에 투입시기도 결정해야함
- 테스트 자동화 도구의 유형 - 실행하지 않고 분석
    - 정적 분석 도구, 테스트 실행 도구, 성능 테스트 도구(가상의 사용자 만들어서 테스트 수행, 목표 달성했는가를 체크)
    - 테스트 통제 도구, 테스트 하네스 도구(모듈을 테스트 하는 환경 일부분, 코드/데이터 의미)
- 테스트 수행 단계별 테스트 자동화 도구
    - 테스트 계획 - 요구사항 관리 (사용자요구사항정의, 변경사항 관리)
    - 테스트 분석,설계 - 테스트 케이스 생성 ; 테스트 데이터, 테스트 케이스 작성 지원
    - 테스트 수행 - 테스트 자동화, 정적 분석(직접 실행하지않고 분석), 동적분석(시스템 시뮬레이션, 오류있나 검출), 성능테스트(처리능력), 모니터링(cpu, 자원상태분석)
    - 테스트관리 - 커버리지 분석(충분여부), 형상관리, 결함추적,관리

- 결함 - 오류 발생!! - 설계한것과 다르게 동작!
- 결함 관리 프로세스
    - 관리 계획 → 기록 → 검토 → 수정 → 재확인 → 결함 상태 추적 모니터링 활동 → 최종 결함 분석 및 보고서 작성
- 결함 상태 추적
    - 결함 분포(결함수 측정), 결함 추세(시간에따른 결함 수), 결함 에이징(특정 결함상태로 지속시간 측정)
- 결함 추적 순서
    - 결함등록 →검토 → 할당(어떤 개발자에게 할당할지) →수정 → 조치보류 → 종료 → 결함 해제

- 결함 분류
    - 시스템 결함(시스템다운, 작동정지), 기능 결함(기능적으로 문제가 있거나, 사용자 요구 미반영, 시스템연동오류), gui결함(화면설계에서 커서 위치나 모달 위치등 오류), 문서결함 (요구사항 불일치로 완전하지 않은 상태의 문서)

    - 결함 심각도
    - high(더이상 진행불가), medium(시스템흐름 영향을 미치고 부정확한 기능), low (이벤트 처리불가 등)

    - 결함 우선순위 - 결함중요도, 심각도
    - 결함 관리 도구 - 발생한 결함을 체계적으로 관리할 수 있도록
        - Mantis-결함 관리도구,단위별작업기록,결함추적 가능, trac - 결함 추적, 통합관리 , redmine - 결함추적 , bugzilla - 결함신고, 확인 , 처리 , 관리도구

앱 성능분석

> 종류, 기능 성능저하요인

- 앱 성능 - 최소한의 자원으로 최대한 많은 기능, 신속
- 처리량(시간- 처리일의 양), 응답시간(요청전달 - 응답 도착), 경과시간(작업의뢰시간 - 처리완료), 자원 사용률(cpu,메모리, 네트워크사용량)
- 성능 테스트 도구
    - jmeter - 다양한프로토콜
    - LoadUi - 사용자 편리성
    - OpenSTA - 부하테스트, 생산품 모니터
- 시스템 모니터링 도구 - 사용량 확인 분석도구
    - scouter - 앱 성능 모니터링,통제 하는도구
    - zabbix →웹 기반 모니터링 도구
- 앱 성능 저하 원인분석
    - **요인** → db 많은 데이터 요구,
    - 커넥션 풀→ db연결된 커넥션을 pool미리 만들어 놓고 pool에서 필요할떄마다 꺼내오고 반납하는 기법 ,
    - connectionpool너무 크거나 작게 설정할 경우

앱 성능 개선 

- 소스코드 최적화
    - 클린코드, 나쁜코드 - 누구나 쉽게 읽을 수 있도록 가독성!!
    - 클린코드 작성원칙 ; 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화
- 소스코드 최적화 유형
    - 클래스 분할 배치, 느슨한 결합(의존성 최소화), 코딩 형식 준수 (호출하는 함수는 앞에 호출되는 함수는 후배치해라!), 좋은 변수명, 적절한 주석사용

앱 성능 개선

- **소스코드 품질 분석 도구** - 결함발견하기 위해 사용하는 도구
    - 정적 분석도구 - 소스코드 실행하지 않고 코딩 표준, 스타일, 결함등을 확인하기 위한것 , 코딩복잡도, 모델의존성, 불일치성을 분석할 수 있음
    - 동적 분석도구 - 직접 소스코드 실행하면서 검사
- 소스코드 품질분석 도구의 종류
    - pmd cppcheck(메모리,오버플로우),sonarQube(코드복잡도,코딩설계), checkstylw(소스코드표준), ccm(코드복잡도), covertura(자바언어소스코드복잡도)  ??→정적
    - avalanche (프로그램결함), valgrind(메모리,쓰레드) ??→ 동적

2-5 인터페이스 구현

모듈간 공통기능 및 데이터 인터페이스 확인 - 모듈 간 연계를 위해 주고받아야 할 데이터 찾기

- 모듈간 공통기능 및 데이터 인터페이스의 개요 - 모듈 기능중에서 공통적으로 제공되는 기능 , 모듈간 교환되는 데이터가 저장될 파라미터 = (데이터인터페이스)
    1. 인터페이스 설계서 - 모듈별로 기능확인
    2. 공통적 제공되는 기능 , 각데이터의 인터페이스 확인 

- **인터페이스 설계서** - 데이터 교환및 처리를 위해 교환 데이터 및 관련 업무, 송-수신 시스템 등에 대한 내용을 정의한 문서
    - 일반적인 인터페이스 설계서 - 시스템, 상세기능별-기능별 세부
    - 정적 동적 모형을 통한 인터페이스 설계서 - 다이어그램, (인터페이스 시스템, 상호교환 트랜잭션종류 )

- 인터페이스 설계서별 모듈 기능 확인
    - 외부모듈 - 송신전달
    - 내부모듈 - 수신
    - 설계서 -  외부-송신

    [제목 없음](https://www.notion.so/0c2d2ef51fdd4c669591b88f2d3458a6)

- 모듈 간 공통 기능 및 데이터 인터페이스 확인

    내외부 에서 공통적인 기능 얘기함 

모듈 연계를 위한 인터페이스 기능 식별  - 외부 ??-내부 를 관계설정하기!

> 연계가 필요한 기능식별 방법!

- 모듈 연계의 개요
    - 연계방법에 EAI, ESB방식 있음

- EAI(enterprise app integration)
    - 기업 내 앱 및 플랫폼 간의 연동 가능하게 해주는 솔루션
    - 비즈니스간 통합 및 연계성 증대, 효율성 및 시스템 간의 확정성높여줌

    - eai 구축유형 ;

        1. point-to-point -app통합방식으로 1:1연결 2. hub&spoke - 중앙집중형방식, 확장및 유지 보수 용이, 허브 장애 발생 시 시스템 전체에 영향미침 

        3. message bus(esb방식) - 앱 사이에 미들웨어를 두어 처리, 확장성 대용량 처리 가능 

        4. hybrid - hub%spoke와 message bus 혼합방식, 그룹내에서는 허브앤 스포크,그룹 간은 메시지 버스 방식, 필요한 경우 한 가지 방식으로 eai 구현 가능, 데이터 병목 현상 최소

- ESB(enterprise Service Bus)
    - 앱 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스 제공
    - 앱 보다는 서비스 중심의 통합 지향
    - 범용적으로 사용하기 위해 앱과 결합(coupling)도 약함
    - 관리 보안 유지 쉽고, 높은 품질 지원 가능

- 모듈 간 연계 기능 식별

- 모듈 간 인터페이스 기능 식별
    - 인터페이스 동작은 대부분 외부 모듈의 결과 또는 요청에 의해 수행되므로 외부 및 인터페이스 모듈 간 동작하는 기능을 통해 인터페이스 기능 식별
    - 내부 모듈의 동작은 외부 모듈에서 호출된 인터페이스에 의해 수행되고 결과를 나타낸 것이므로 시나리오를 통해 내부 모듈과 관련된 인터페이스 기능을 식별
    - 

**13 처음부터 다시 듣기 

## 3-1 데이터베이스 설계

> 설계 순서와 각 단계별 특징!

데이터베이스 설계의 개념 - 사용자 요구를 분석하여 컴퓨터에 저장후 dbms로 데이터베이스를 구현해 일반 사용자들이 사용하게 하는것 

데이터베이스 설계 시 고려사항 

- 무결성 ; crud 등의 연산 후에도 db에 저장된 데이터가 정해진 제약 조건 항상 만족해야함
- 일관성 ; 데이터들 사이, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야함
- 회복 ; 장애 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함
- 보안 ; 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야함
- 효율성 ; 응답시간 단축, 시스템 생산성, 저장 공간 최적화 가능해야함
- 데이터베이스 확장 ; db 운영에 영향을 주지 않으면서 지속적으로 데이터 추가할 수 있어야함

데이터베이스 설계 순서

요구 조건분석(요구조건 명세서 작성)→ 개념적설계(개념 스키마, 트랜잭션 모델링, e-r모델) → 논리적설계(목표 dbms에 맞는 논리 스키마설계, 트랜잭션 인터페이스 설계)→ 물리적설계 (목표 dnms에 맞는 물리적 구조의 데이터로 변환)→ 구현(목표 dbms의 ddl{데이터 정의어} 로 데이터베이스 생성, 트랜잭션 작성) 

요구 조건 분석 - db를 사용할 사람들로부터 필요한 용도를 파악하는것

- 디비 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집
- 수집된 정보를 바탕으로 요구 조건 명세 작성

개념적 설계(정보 모델링, 개념화) - 정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성 이해, 다른 사람과 통신하기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 개념적 설계 단계에서 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
- 개념적 설계 단계에서 요구 분석 단계에서 나온 결과인 요구 조건 명세를 dbms에 독립적인 e-r 다이어그램으로 작성
- dbms에 독립적인 개념 스키마 설계

논리적 설계(데이터 모델링) -현실세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 dbms가 지원하는 논리적 자료 구조로 변환 시키는 과정

- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마를 평가 및 정제하고 dbms에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스 설계
- 관계형 db라면 테이블을 설계하는 단계

물리적 설계(데이터 구조화) - 논리적 설계단계에서 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정

- 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일으 ㅣ저장 구조 및 엑세스 경로를 결정
- 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사

데이터베이스 구현 - 논리적 설계 단계와 물리적 설계 단계에서 도출된 데이터 베이스 스키마를 파일로 생성하는 과정 

- 사용하려는 특정 dbms의 ddl을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성
- 생성된 빈 데이터베이스 파일에 데이터를 입력
- 응용 프로그램을 위한 트랜잭션을 작성
- 데이터베이스 접근을 위한 응용 프로그램 작성